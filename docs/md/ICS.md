# 计算机系统基础

## 目录

[TOC]

## 3.程序的转换及机器级表示

### 1.程序转换概述

微指令	伪指令	机器指令	汇编指令	机器级指令

寄存器传送语言 Register Transfer Language RTL

指令集体系结构 Instruction Set Architecture ISA

（源程序）预处理（预处理的源程序）编译（汇编语言程序）汇编（可重定位机器语言目标代码文件）链接（可执行文件）

一个C程序包含两个源程序文件

`gcc -O1 prog1.c prog2.c -o prog`

`gcc -E test.c -o test.i`预处理后文件

`gcc -S test.i -o test.s`汇编代码文件

`gcc -c test.s -o test.o`可重定位目标文件	（不可显示的二进制文件）

`objdump -d test.o`反汇编

`gcc`生成的汇编用十进制表示数值，而`objdump`反汇编用十六进制表示数值

以\$开头表示一个立即数

l操作数双字32位

w操作数单字16位

在AT&T格式中，b(byte)8位，w(word)16位，l(long)32位, q(quadruple?)64位

寄存器操作数	% + 寄存器名

存储器操作数	偏移量（基址寄存器，变址寄存器，比例因子）

100(%ebx, %esi, 4) => M[R[edx] + 4 * R[esi] + 100]

在C语言程序中直接嵌入汇编语句，格式：__asm 汇编指令

### 2.IA-32指令系统概述

#### 数据类型及其格式

C语言程序中的基本数据类型：

1. 指针或地址：用来表示字符串或其他数据区域的指针或存储地址，可声明为char*等，宽度32位
2. 序数、位串等 unsigned char、unsigned[int]等
3. 带符号整数
4. 浮点数

#### 寄存器组织和寻址方式

不考虑I/O指令，IA-32指令的操作数有三类：立即数、寄存器操作数、存储器操作数

8个通用寄存器：

EAX,累加器，EBX,基址寄存器，ECX,计数寄存器，EDX，数据寄存器，可8位，16位，32位

ESP栈指针寄存器，EBP基址指针寄存器，ESI源变址寄存器，EDI目标变址寄存器，可16位，32位

EIP指针指令寄存器（PC）

EFLAGS标志寄存器

寻址方式

立即寻址 寄存器寻址 存储器操作数

LA：线性地址

| 寻址方式             | 说明                        |
| -------------------- | --------------------------- |
| 立即寻址             | 指令直接给出操作数          |
| 寄存器寻址           | 指定的寄存器R的内容为操作数 |
| 位移                 | LA=(SA)+A                   |
| 基址寻址             | LA=(SA)+(B)                 |
| 基址加位移           | LA=(SA)+(B)+A               |
| 比例变址加位移       | LA=(SA)+(I)*S+A             |
| 基址加变址加位移     | LA=(SA)+(B)+(I)+A           |
| 基址加比例变址加位移 | LA=(SA)+(B)+(I)*S+A         |
| 相对寻址             | LA=(PC)+A                   |

S：比例系数，含义为操作数的字节个数，在IA-32中，S的取值可以是1、2、4、8。例如，对数组元素访问时，若数组元素的类型为short，则比例系数就是2；例如，若数组元素类型为char，则比例系数就是1，即非比例编址方式。

对于数组元素的访问可以采用“基址加比例变址”的寻址方式，假设C语言程序中有变量声明`int a[100];`，若数组`a`的首地址存放在EBX寄存器，下标变量`i`存放在ESI寄存器，则实现将`a[i]`送EAX，指令可以是`movl (%ebx, %esi, 4), %eax`

对于结构类型中的数组元素访问可以采用“基址加比例变址加位移”，例如，`struct { int x; short a[100]; ...}` `movl 4(%ebx, %esi, 2), %eax`

#浮点数跳过

### 3.IA-32常用指令类型及其操作

#### 1.传送指令

##### 通用数据传送指令

mov一般的传送指令

movs（s=sign expanded）

movz（z=zero expanded）

push先执行`R[esp]<-R[esp]-4`然后将双字从指定寄存器送到ESP指示的栈单元

pop 将push反过来

##### 地址传送指令

地址传送指令传送的是操作数的存储地址

主要是**加载有效地址**(Load Effect Address, LEA)指令

例如，`i+j` `leal (%edx, %eax), %eax`执行前`R[edx]=i, R[eax]=j`，执行后`R[eax]=i+j`

##### 输入输出指令

in 指令用于将I/O端口内容送累加器，

out 指令将累加器内容送I/O端口

##### 标志传送指令

pushf popf

注：lea与mov的区别

lea指令可以用来将一个内存地址直接赋给目的操作数

例如，

`lea eax, [ebx+8]`就是将ebx+8这个值直接赋给eax

`mov eax, [ebx+8]`则是把内存地址为ebx+8处的数据赋给eax

#### 2.定点算数运算指令

加/减	ADD/SUB

增/减	INC/DEC

取负	NEG

比较	CMP

乘/除	MUL/IMUL	DIV/IDIV

#### 3.按位运算指令

逻辑运算指令

NOT	AND	OR	XOR	TEST

移位指令

SHL：逻辑左移，低位补0

SHR：逻辑右移，高位补0

SAL：算数左移，低位补0，与逻辑左移的区别在于，若算数左移前后符号位发生变化，则OF=1，表示溢出

SAR：算数右移，高位补符号

#### 4.控制转移指令

无条件转移指令

条件转移指令

条件设置指令

条件传送指令

调用和返回指令

中断指令

### 4.C语言程序的机器级表示

#### 1.过程调用的机器级表示

为了支持嵌套和递归调用，通常利用栈来保存返回地址、入口参数和非静态局部变量

CALL指令在跳转到被调用过程执行之前先要把返回地址压栈

RET指令在返回调用过程之前要从栈中取出返回地址

过程调用的执行步骤：

假定过程P调用过程Q，过程调用的执行步骤如下

1. P将入口参数放到Q能访问到的地方
2. P将返回地址存到特定地方，然后将控制转移到Q
3. Q保存P的现场，并为自己的非静态局部变量分配空间
4. 执行Q的过程体
5. Q恢复P的现场，并释放局部变量所占空间
6. Q取出返回地址，将控制转移到P

ABI（应用程序二进制接口Application Binary Interface）规定，

寄存器EAX、ECX、EDX是调用者保存寄存器，Q可以直接使用，不用将它们的值保存到栈中

寄存器EBX、ESI、EDI是被调用者保存寄存器，Q必须先将它们的值保存到栈中再使用它们，并在返回P之前先恢复它们的值

EBP帧指针寄存器，指向当前栈帧的底部

ESP栈指针寄存器，指向当前栈帧的顶部

注：栈在内部存储中

由图可看出，在Q的过程体执行时，入口参数1的地址总是R[ebp]+8，入口参数2的地址总是R[ebp]+12，依此类推

#### 2.选择语句的机器级表示

##### 1.条件运算表达式的机器级表示

##### 2.if ~ else语言的机器级表示

```
	c=cond_expr;
	if(!c)
		goto false_label;
	then_statement
	goto_done
false_label:
	else_statement
done:
```

或者

```
	c=cond_expr;
	if(c)
		goto true_label;
	then_statement
	goto_done
true_label:
	else_statement
done:
```

##### 3.switch语句的机器级表示

#### 3.循环结构的机器级表示

##### 1.do~while循环的机器级表示

```
loop:
	loop_body_statement
	c = cond_expr;
	if (c) goto loop;
```

##### 2.while循环的机器级表示

```
	c = cond_expr;
	if (!c) goto done;
loop:
	loop_body_statement
	c = cond_expr;
	if (c) goto loop;
done:
```

##### 3.for循环的机器级表示

```
	begin_expr;
	c = cond_expr;
	if (!c) goto done;
loop:
	loop_body_statement
	update_expr;
	c = cond_expr;
	if (c) goto loop;
done:
```

### 5.复杂数据类型的分配和访问

#### 1.数组的分配和访问

#### 2.结构体数据的分配与访问

#### 3.联合体数据的分配与访问

#### 4.数据的对齐

### 6.越界访问和缓冲区溢出

### 7.兼容IA-32的64位系统

### 习题



## 4.程序的链接

将一个程序的所有关联模块对应的代码结合在一起，形成一个可执行文件

4.1编译、汇编和静态链接

4.1.1编译和汇编

预处理、编译、汇编和链接四个步骤

前三个步骤生成可重定位目标文件（.o文件）

可移植可执行格式PE

可执行可链接格式ELF

ELF格式的基本框架，

链接视图主要由不同的节组成，不同的节描述了目标文件中不同类型的信息及其特征，例如，代码节.text、只读数据节.rodata、已初始化全局数据节.data、未初始化全局数据节.bss等

执行视图主要由不同的段组成，描述了目标文件中的节如何映射到存储空间的段中

节头表包含文件中各节的说明信息，指定了节名和节大小之类的信息

用于链接的目标文件必须具有节头表

程序头表

4.2.2可重定位目标文件格式

## 6.层次结构存储系统

按存取方式分内

RAM随机存取存储器(random access memory)

SAM顺序存取存储器(sequential access memory)

DAM直接存取存储器(direct access memory)

CAM按内容访问存储器(content addressed memory)或者AM相联存储器(associative memory)

按信息的可更改性分类

ROM只读存储器(read only memory)

RAM

按功能分类

高速缓冲存储器	cache位于主存和cpu之间

主存储器

辅助存储器

海量后备存储器

辅助存储器和海量后备存储器统称为外部存储器

主存

记忆单元cell 存储阵列bank 编址方式 按字节编址 按字编址

SRAM静态 cache

DRAM动态 主存

ROM 监控程序 启动程序 控制存储器 存放微程序 ...

闪存 flash存储器 u盘 存储卡

位片式芯片

总线

虚拟存储器

存储器管理部件MMU Memory Management Unit

逻辑地址 也称虚拟地址VA

物理地址 也称主存地址PA

进程

分页式虚拟存储器

未分配页 缓存页 未缓存页

主存块 <---> 页面

回写方式 全相联映射

页表：描述虚拟页与空闲页框的对应关系

进程中的每个虚拟页在页表中都有一个对应的表项，称为页表项

操作系统在加载程序时，根据可执行文件中的程序头表，确定每个可分配段所在的虚页号及其磁盘存放位置，在主存生成一个初始页表，装入位初始都为0

页表属于进程控制信息，位于虚拟地址空间的内核空间

页表在主存的首地址记录在页表基址寄存器
